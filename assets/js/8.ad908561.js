(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{327:function(s,e,t){"use strict";t.r(e);var v=t(7),_=Object(v.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"es6面向对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6面向对象"}},[s._v("#")]),s._v(" ES6面向对象")]),s._v(" "),e("h1",{attrs:{id:"常见问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[s._v("#")]),s._v(" 常见问题")]),s._v(" "),e("blockquote",[e("p",[s._v("项目是自己做的吗?为什么做这样的一个项目?做这个项目的背景(初衷)是什么?")])]),s._v(" "),e("p",[s._v("初衷是尽可能地帮助和服务更多的用户和开发者，让他们更加方便快捷地获取他们想要的信息和功能。接口开放平台它可以帮助开发者快速接入一些常用的服务，从而提高他们的开发效率，比如天气服务、随机头像等常见的基础服务，它们是一些应用或者小程序中常见的功能，所以提供这些接口可以帮助开发者更加方便地实现这些功能。这些接口也可以让用户在使用应用时获得更加全面的功能和服务，从而提高他们的用户体验。同时也支持其他开发者开放自己的接口，不论是基于开源精神或是正常的收费需求，都允许在此实现。所以我认为接口开放平台是一个有意义的项目，可以为用户和开发者带来更多的便利和价值。")]),s._v(" "),e("blockquote",[e("p",[s._v("项目的架构是怎么设计的?")])]),s._v(" "),e("p",[s._v("采用前后端分离的架构，前端使用Nginx部署，通过Nginx反向代理将请求转发至API网关。因为项目刚刚上线，所以暂时采用单机部署的模式，未来可能采取水平扩容的方式，增加多台节点，通过Nginx的负载均衡，将请求平均的分发到我的每个节点上，以支撑更高的并发。不同模块基于Spring Boot开发，最终统一聚合。考虑未来可能采用分布式架构，所以通过Redis实现了分布式session。")]),s._v(" "),e("blockquote",[e("p",[s._v("如何做的技术选型?为什么要用这些技术?")])]),s._v(" "),e("p",[s._v("在开发客户端SDK时，对诸如腾讯SDK平台的实现进行了调研，最终决定使用HTTPS进行端到端的连接，确保数据的安全性。并使用成熟的加密算法以及签名认证确保数据的可靠性。在进行实际实现时，对Nacos的服务注册与心跳续约机制，Swagger的关键功能实现方式以及Ice的架构设计进行了调研。最终设计出基于Netty实现连接与数据读取的SDK。其他技术如Redis，主要用来实现分布式Session，锁，缓存等。Redis是一个单独的中间件，不同客户端可以往同一个Redis或者集群中存放session/加锁，这样就能保证资源能够在分布式服务下都可见。并且由于Redis也是单线程的，同时也支持lua脚本，可以保证并发安全的问题，可以很简单的实现分布式锁的功能。使用MQ是为了保证在通讯模块尽量确保消息不丢失与推送，并在其他功能点进行异步解耦与流量削峰。")]),s._v(" "),e("blockquote",[e("p",[s._v("开发流程是什么?先实现还是先技术选型?")])]),s._v(" "),e("p",[s._v("先参考了一些已有的产品，根据这些产品，总结出来比较好的功能点，再结合自己想要实现的一些功能特色，去做了一个项目整体设计，有了产品原型后再进行技术选型。使用什么样的技术去解决什么样的业务问题。")]),s._v(" "),e("blockquote",[e("p",[s._v("为什么要使用网关?")])]),s._v(" "),e("p",[s._v("本平台的关键点在于提供接口服务，要保证接口的可用性和稳定性，所以将接口服务独立部署在另一台机器上，隐藏真实的接口地址及端口，调用接口服务的请求都必须经过网关流量染色之后.….(这里细节太多，比如rpc调用获取用户sk，重新生成签名认证等等)之后，将请求转发到真实的接口地址，防止接口被恶意调用、盗刷。")]),s._v(" "),e("blockquote",[e("p",[s._v("为什么使用RPC调用?有了解过其他的方式吗?")])]),s._v(" "),e("p",[s._v("如果在网关引入数据库的操作的话，不仅会增加项目体积，也会违背设计原则的单一职责原则，所以考虑通过服务间调用的方式，了解过两种方式，一种是Open feign，原理是构造了一个HTTP请求，并会添加很多的请求头，body是使用json字符串传输，调用效率会比较低，更加适合外部服务间的调用。相比之下RPC基于TCP协议，避免了无用的请求头，可以通过将数据序列化为二进制流的形式传输，效率更加高效，更加安全，所以更适用于本项目场景。最终选择了Dubbo RPC框架来实现这个功能。")]),s._v(" "),e("blockquote",[e("p",[s._v("接口调用次数统计以及排行是怎么实现的?")])]),s._v(" "),e("p",[s._v("通过Mysq统计，每次调用结束后，网关都会发起一个rpc请求，调用次数+1。\n注:设计缺陷，在实际测试过程中，通过jmeter压测工具，会出现调用次数不准的情况，原因是因为没有在业务层面加锁，导致数据库出现并发写的问题。并且并发量大的话，对数据库造成很大的压力。")]),s._v(" "),e("p",[s._v("有什么更好的解决方案吗?\n如果在业务层面加一个写锁的话，会影响业务的执行效率，所以我想使用Redis去解决，Redis有一个数据结构Zset支持排序，score可以用来存储调用次数，并且Redis是单线程，可以解决并发问题。")]),s._v(" "),e("blockquote",[e("p",[s._v("做过什么优化吗?接口的性能怎么样?")])]),s._v(" "),e("p",[s._v("项目开发接近尾声时会对接口做qps测试，比如对只有读操作的数据库表进行存储引擎的更改或索引的使用以提升qps。")])])}),[],!1,null,null,null);e.default=_.exports}}]);